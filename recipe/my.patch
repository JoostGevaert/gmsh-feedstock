diff --git a/CMakeLists.txt b/CMakeLists.txt
index 2757b4545..2346c8644 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -380,11 +380,11 @@ if(ENABLE_BLAS_LAPACK)
       # blas/lapack libs (useful for users with no Fortran compiler and no MKL
       # license, who can just download our precompiled "gmsh-dep" package)
       if(HAVE_64BIT_SIZE_T)
-        set(MKL_PATH em64t/lib)
-        set(MKL_LIBS_REQUIRED libguide40 mkl_intel_lp64 mkl_intel_thread mkl_core)
+        set(MKL_PATH Library/lib)
+        set(MKL_LIBS_REQUIRED mkl_intel_lp64_dll mkl_intel_thread_dll mkl_core_dll)
       else()
-        set(MKL_PATH ia32/lib)
-        set(MKL_LIBS_REQUIRED libguide40 mkl_intel_c mkl_intel_thread mkl_core)
+        set(MKL_PATH Library/lib)
+        set(MKL_LIBS_REQUIRED mkl_intel_c_dll mkl_intel_thread_dll mkl_core_dll)
       endif()
       find_all_libraries(LAPACK_LIBRARIES MKL_LIBS_REQUIRED "" ${MKL_PATH})
       if(LAPACK_LIBRARIES)
@@ -543,7 +543,7 @@ if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/Fltk AND ENABLE_FLTK)
   if(FLTK_CONFIG_SCRIPT)
     execute_process(COMMAND ${FLTK_CONFIG_SCRIPT} --api-version
                     OUTPUT_VARIABLE FLTK_VERSION)
-    string(STRIP ${FLTK_VERSION} FLTK_VERSION)
+    string(STRIP "${FLTK_VERSION}" FLTK_VERSION)
     if(FLTK_VERSION GREATER 1.1)
       add_subdirectory(Fltk)
       set_config_option(HAVE_FLTK "Fltk")
diff --git a/Geo/GModel.cpp b/Geo/GModel.cpp
index 07f2ed20a..82389b663 100644
--- a/Geo/GModel.cpp
+++ b/Geo/GModel.cpp
@@ -612,7 +612,7 @@ bool GModel::getBoundaryTags(const std::vector<std::pair<int, int> > &inDimTags,
       int dim = outDimTags[i].first;
       int tag = outDimTags[i].second;
       if(dim >= 0 && dim < 3) {
-        std::set<int>::iterator it = c[dim].find(tag);
+        std::set<int, AbsIntLessThan>::iterator it = c[dim].find(tag);
         if(it == c[dim].end())
           c[dim].insert(tag);
         else {
@@ -622,7 +622,7 @@ bool GModel::getBoundaryTags(const std::vector<std::pair<int, int> > &inDimTags,
     }
     outDimTags.clear();
     for(int dim = 0; dim < 3; dim++) {
-      for(std::set<int>::iterator it = c[dim].begin(); it != c[dim].end(); it++)
+      for(std::set<int, AbsIntLessThan>::iterator it = c[dim].begin(); it != c[dim].end(); it++)
         outDimTags.push_back(std::pair<int, int>(dim, *it));
     }
   }
@@ -900,7 +900,7 @@ addToMap(std::multimap<MFace, MElement *, Less_Face> &faceToElement,
            &elToNeighbors,
          const MFace &face, MElement *el)
 {
-  std::map<MFace, MElement *, Less_Face>::iterator fit =
+  std::multimap<MFace, MElement *, Less_Face>::iterator fit =
     faceToElement.find(face);
   if(fit == faceToElement.end()) {
     faceToElement.insert(std::pair<MFace, MElement *>(face, el));
diff --git a/Geo/GModelIO_NEU.cpp b/Geo/GModelIO_NEU.cpp
index 55043425e..98cb311bf 100644
--- a/Geo/GModelIO_NEU.cpp
+++ b/Geo/GModelIO_NEU.cpp
@@ -7,6 +7,7 @@
 
 #include <time.h>
 #include <algorithm>
+#include <iterator>
 #include <limits>
 #if __cplusplus >= 201103L
 #include <unordered_map>
diff --git a/Geo/GeomMeshMatcher.cpp b/Geo/GeomMeshMatcher.cpp
index 129e64450..36fe51c2d 100644
--- a/Geo/GeomMeshMatcher.cpp
+++ b/Geo/GeomMeshMatcher.cpp
@@ -605,7 +605,7 @@ static void copy_periodicity (std::vector<Pair<GEType*, GEType*> >& eCor,
     if (oldSrc != NULL && oldSrc != oldTgt) {
 
       GEType* newTgt = srcIter->second;
-      typename std::map<GEType*,GEType*>::iterator tgtIter = eMap.find(oldSrc);
+      typename std::multimap<GEType*,GEType*>::iterator tgtIter = eMap.find(oldSrc);
       if (tgtIter == eMap.end()) {
         Msg::Error("Could not find matched entity for %d",
                    "which has a matched periodic counterpart %d",
diff --git a/Mesh/HighOrder.cpp b/Mesh/HighOrder.cpp
index a3dfefe9b..7aa45488a 100644
--- a/Mesh/HighOrder.cpp
+++ b/Mesh/HighOrder.cpp
@@ -1367,7 +1367,7 @@ static void updatePeriodicEdgesAndFaces(GModel *m)
             vtcs.push_back(tIter->second);
         }
 
-        std::map<MFace, MElement *>::iterator srcIter =
+        std::map<MFace, MElement *, Less_Face>::iterator srcIter =
           srcFaces.find(MFace(vtcs));
         if(srcIter == srcFaces.end()) {
           std::ostringstream faceDef;
diff --git a/Mesh/meshGFaceBDS.cpp b/Mesh/meshGFaceBDS.cpp
index b92f5953c..285c6b4c7 100644
--- a/Mesh/meshGFaceBDS.cpp
+++ b/Mesh/meshGFaceBDS.cpp
@@ -1036,7 +1036,7 @@ int solveInvalidPeriodic(
 
   std::set<BDS_Edge *, EdgeLessThan> toSplit;
   invalidEdgesPeriodic(m, recoverMap, toSplit);
-  std::set<BDS_Edge *>::iterator ite = toSplit.begin();
+  std::set<BDS_Edge *, EdgeLessThan>::iterator ite = toSplit.begin();
 
   Msg::Debug("%d edges of the initial mesh are going to be split",
              toSplit.size());
diff --git a/Parser/Parser.h b/Parser/Parser.h
index fd310e0cd..2325a3d2e 100644
--- a/Parser/Parser.h
+++ b/Parser/Parser.h
@@ -6,6 +6,7 @@
 #ifndef _PARSER_H_
 #define _PARSER_H_
 
+#include <algorithm>
 #include <map>
 #include <string>
 #include <vector>
diff --git a/contrib/MeshOptimizer/MeshOptimizer.cpp b/contrib/MeshOptimizer/MeshOptimizer.cpp
index 9582baf76..2c26d9434 100644
--- a/contrib/MeshOptimizer/MeshOptimizer.cpp
+++ b/contrib/MeshOptimizer/MeshOptimizer.cpp
@@ -361,7 +361,7 @@ namespace {
                           const elSet &elts, elSet &bndElts,
                           MeshOptParameters &par)
   {
-    for(elSetIter itEl = elts.begin(); itEl != elts.end(); itEl++) {
+    for(elSet::const_iterator itEl = elts.begin(); itEl != elts.end(); itEl++) {
       elElMap::const_iterator itBndEl = el2BndEl.find(*itEl);
       if(itBndEl != el2BndEl.end()) {
         MElement *bndEl = itBndEl->second;
